# WHY ZYNG (v0.1 設計メモ)

この文書は、Zyng の「何を目指すか」「何を目指さないか」、そして設計原則を自分用に整理したメモです。  
Core 構文や仕様を追加・変更するときの判断基準として使います。

---

## 1. Zyng の目的（What Zyng aims for）

Zyng は次のような状況をターゲットにしています。

- LLM プロジェクトで
  - プロンプト
  - ワークフロー
  - 設定
  - ログ
  - 軽いテスト
- が、Markdown / YAML / JSON / Python / コメントなどにバラバラに散らばり、
  - README と実態がズレる
  - ログを後から読んでも「いつ」「どの前提」で動いたのかわからない
  - 「これはログ用？学習用？テスト用？」が曖昧になる

Zyng の目的は：

> **LLM のワークフローとログを、  
> 時間とメタデータつきの「実行可能なテキスト」として  
> 一枚で書けるようにすること。**

具体的には：

- README や `.md` ファイルの中に
  - プロンプト
  - ワークフロー
  - ログ
  - メタ情報
- を timeline-first に書き、そのまま runner で実行できる状態にすることを目指します。

---

## 2. Zyng が目指さないもの（Non-goals）

Zyng が **やらない／優先しない** と決めていること：

- 汎用プログラミング言語として、Python や Rust と競合すること
- 高速なランタイムや高度な型システムで勝負すること
- すべての設定ファイルやコードを Zyng に置き換えること
- LLM バックエンド（OpenAI / Claude / Gemini / ローカル LLM など）の代わりになること

重い計算やアプリケーション本体は、これまで通り Python や他の言語に任せます。  
Zyng が扱うのは、**LLM 周りのテキスト層（ワークフロー・ログ・設定の「人間向けの顔」）**です。

---

## 3. 設計原則（Design Principles）

### 3-1. Timeline-first 原則

- 何より先に「いつの話か（time）」を重視する
- 各行が「どの時点の前提／出来事／ログか」を持つことを目指す
- `:::now` / `:::yest` / `:::tomo` / `:::at:"..."` など、time を言語レベルで露出させる

→ 構文や機能を追加するときは、  
**「time とどう結びつくか？」を必ず検討する。**

---

### 3-2. Text-first 原則（テキストが一次成果物）

- Zyng で書かれたテキスト（README, .md, .zyng）が一次成果物
- AST / JSON / Python dict はそこから派生する二次成果物
- README やドキュメントが、
  - 仕様
  - ログ
  - 半分コード
  を兼ねる状態を優先する

→ 「テキストとして読んだときに意味が通るか？」を常にチェックする。

---

### 3-3. Human-first, Model-second 原則

- 優先順位：
  1. 人間が読む／書くときに破綻しない
  2. LLM が構造化しやすい
- 目指すのは「少し変な英語だが、がんばれば声に出して読める」レベル
- モデル都合だけで記号まみれにしない（特に Core は抑制的に）

→ 「モデル的には嬉しいが人間にはキツい」設計は、Core ではなく拡張側に追いやる。

---

### 3-4. Minimal Core 原則

- Core に入る語彙・構文はできるだけ少なく保つ
- Core の役割は、LLM ワークフローの前段に必要な最低限：
  - `show`
  - `read`
  - `write`
  - `use`
  - `let`
  - time メタ (`now` / `yest` / `tomo` / `at:"..."` など)
- それ以外の「便利だけど重たい」機能は Python 側・拡張側に逃がす

→ 新しい機能を考えるときは：

- 「LLM ワークフロー＋ログを一枚で書くのに、本当に Core に必要か？」
- 「これは Zyng ではなく Python でやってもよくないか？」

を毎回自問する。

---

### 3-5. Metadata-explicit 原則（time / role / kind / use）

- time / role / kind / use は、できるだけ**明示的な構文**として表現する
- メタ情報を別ファイルや隠れた設定に追い出すのではなく、行のそばに書く
- 長期的には、次のようなメタを自然に書けることを目指す：

  - `:::role:"user"`
  - `:::kind:"fact"`
  - `:::use:"log"`

→ 「暗黙の前提にしている情報は、メタとして明示すべきでは？」を常に疑う。

v0.0.1 〜 v0.1 では time の扱いを優先し、  
role / kind / use は設計段階のキーワードとして扱う。

---

### 3-6. Front-end DSL 原則（バックエンドを置き換えない）

- Zyng は Python や LLM API の **前段に座る DSL** として振る舞う
- バックエンド（モデル実装や重い処理）を置き換えようとしない
- ループや高度な制御構文・型システムなど、汎用言語化に向かう機能は慎重に扱う

→ 「ここから先は Python に任せる」という境界を意識的に引く。

---

### 3-7. Export-friendly 原則（輸入されることも成功とみなす）

- Zyng 自体が標準になるかどうかは保証しない
- それでも、
  - time / role / kind / use の考え方
  - timeline-first なログの書き方
  - README 実行という発想
- などの設計アイデアが、他のツールや言語に「輸入される」ことも成功とみなす

→ 仕様やドキュメントは、他の開発者がアイデアを取り込みやすいように整理しておく。

---

## 4. 現状と今後のメモ

- 現在（v0.0.1）：
  - PyPI: `zyng==0.0.1`
  - Markdown 内の ```zyng ブロックを runner で実行可能
  - `show` ＋ `now / yest / tomo / at:"..."` という最小限の time メタ

- v0.1 の目標：
  - Core の語彙（`show` / `read` / `write` / `use` / `let`）を明確にする
  - time を安定させる（挙動・フォーマットを固める）
  - README を「実行可能ドキュメント」として扱いやすくする

この文書は、必要に応じて更新する。  
更新するときは、「上記の原則を変えるのか／追加の原則を足すのか」を意識して差分を見る。
